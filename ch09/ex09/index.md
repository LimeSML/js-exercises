# SOLID 原則

## 単一責任の原則 (single-responsibility principle)

クラスや関数は、単一の目的や責任（役割）に集中させるべきとする考え。
1つのクラスに複数の責任があると、ある責任に対する変更が、他の責任に予期しない影響を及ぼす可能性がある。
結果として、バグの発生や保守性の低下を招いてしまう。

```js
// ----- 満たさないコード -----
class User {
    id: number;
    name: string;

    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }

    // ユーザー登録
    register() {}

    // ユーザー削除
    delete() {}
}

// ----- 満たすコード -----
class User {
    id: number;
    name: string;

    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }
}

class UserService {
    // ユーザー登録
    register() {}

    // ユーザー削除
    delete() {}
}
```

## 開放閉鎖の原則（open/closed principle）

コードは、拡張に対して開かれ、修正に対して閉じているべきとする考え。
既存のコードを変更せずに、新しい振る舞いを追加できるように設計する。
条件分岐の追加や既存ロジックの修正ではなく、継承、ポリモーフィズム、依存性の注入などを用いて拡張性を持たせる。

## リスコフの置換原則（Liskov substitution principle）

あるクラスのインスタンスを、その派生クラスのインスタンスに置き換えても、プログラムの動作が正しく保たれるべきとする考え。
継承関係にある場合、置き換えによってエラーが発生したり、意味が破綻したりするような設計は避けなければならない。

## インターフェース分離の原則 (Interface segregation principle)

使わない機能への依存を強制されるべきではないという考え方。
1つのインターフェースに多くのメソッドを詰め込むと、すべてを実装する必要があり、不要な依存が発生する。
そのため、クライアントが必要としないメソッドは持たせないよう、インターフェースを細かく分割するべき。

## 依存性逆転の原則（dependency inversion principle）

上位モジュールは下位モジュールに依存すべきではなく、どちらも抽象（インターフェースや抽象クラス）に依存すべきという考え。
これにより、具象の変更が上位モジュールに影響を及ぼさなくなり、モジュール同士の独立性と再利用性が高まる。
